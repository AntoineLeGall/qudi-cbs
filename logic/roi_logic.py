#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Nov  9 06:22:29 2020

@author: fbarho

This module contains the ROI selection logic.
It is in large parts taken and adapted from the qudi poimanager logic, in this version reduced to 
the functionality that we need. 
ROIs are regrouped into an ROI list (instead of using the terminology of POI in ROI
or, as in the current labview measurement software ROIs per embryo.) 
The chosen nomenclature is more flexible than regrouping by embryo and can be extended to other 
types of samples. Moreover, it is planned to add a serpentine scan over a sample area and 
decide which ROI belongs to which object in the analysis step.
"""


import os
import numpy as np
import time

from collections import OrderedDict
from core.connector import Connector
from core.statusvariable import StatusVar
from datetime import datetime
from logic.generic_logic import GenericLogic
from qtpy import QtCore
from core.util.mutex import Mutex


class RegionOfInterestList:
    """
    Class containing the general information about a specific list of regions of interest (ROI),
    e.g. the sample drift history and the corresponding confocal image. # to change ! These information will not be needed here
    Each individual ROI will be represented as a RegionOfInterest instance.
    The origin af a new ROI is always defined as (0,0,0) initially.
    Sample shifts will cause this origin to move to a different coordinate.
    The anchors of each individual ROI is given relative to the initial ROIList origin (even if added later).
    
    Class containing a collection of ROIs.
    Each individual ROI will be represented as a RegionOfInterest instance.
    """

    def __init__(self, name=None, creation_time=None, cam_image=None,
                 cam_image_extent=None, roi_list=None, roi_nametag=None):
        # keep the keyword arguments as is, the unused ones will be set to None as default
        # clean up in later version to keep only the ones that are required 
        
        # Remember the creation time for drift history timestamps
        self._creation_time = None

        # Optional camera image associated with this ROI
        self._cam_image = None
        # Optional initial camera image extent.
        self._cam_image_extent = None
        # Save name of the ROIlist. Create a generic, unambiguous one as default.
        self._name = None
        # Nametag for ROIs. If you add a ROI without explicitly setting a name, the name will be
        # generated by using the nametag and appending it with consecutive integer numbers.
        # to be set as format ROI_000 etc 
        self._roi_tag = None
        # dictionary of ROIs contained in this ROIlist with keys being the name
        self._rois = dict()

        self.creation_time = creation_time
        self.name = name
        self.roi_nametag = roi_nametag
        #self.set_cam_image(cam_image, cam_image_extent)
        if roi_list is not None:
            for roi in roi_list:
                self.add_roi(roi)
        return None

    @property
    def name(self):
        return str(self._name)

    @name.setter
    def name(self, new_name):
        if isinstance(new_name, str) and new_name:
            self._name = str(new_name)
        elif new_name is None or new_name == '':
            self._name = self._creation_time.strftime('roilist_%Y%m%d_%H%M_%S_%f') ## modify the default roilist name 
        else:
            raise TypeError('ROIlist name to set must be None or of type str.')
        return None

    @property
    def roi_nametag(self):
        return str(self._roi_tag) if self._roi_tag is not None else None

    @roi_nametag.setter
    def roi_nametag(self, new_tag):
        if new_tag is None:
            self._roi_tag = None
        elif isinstance(new_tag, str):
            self._roi_tag = str(new_tag)
        else:
            raise TypeError('ROI name tag to set must be None or of type str.')
        return None


    @property
    def creation_time(self):
        return self._creation_time

    @property
    def creation_time_as_str(self):
        return datetime.strftime(self._creation_time, '%Y-%m-%d %H:%M:%S.%f')

    @creation_time.setter
    def creation_time(self, new_time):
        if not new_time:
            new_time = datetime.now()
        elif isinstance(new_time, str):
            new_time = datetime.strptime(new_time, '%Y-%m-%d %H:%M:%S.%f')
        if isinstance(new_time, datetime):
            self._creation_time = new_time
        return

    @property
    def origin(self):
        return np.zeros(3) # no drift correction so origin is set to 0 and does not move over time
        #return np.array(self._pos_history[-1][1:], dtype=float)

    @property
    def cam_image(self):
        return self._cam_image

    @property
    def cam_image_extent(self):
        if self._cam_image_extent is None:
            return None
        x, y, z = self.origin
        x_extent = (self._cam_image_extent[0][0] + x, self._cam_image_extent[0][1] + x)
        y_extent = (self._cam_image_extent[1][0] + y, self._cam_image_extent[1][1] + y)
        return x_extent, y_extent

    @property
    def roi_names(self):
        return list(self._rois)

    @property
    def roi_positions(self):
        origin = self.origin
        return {name: roi.position + origin for name, roi in self._rois.items()}
 

#    @property
#    def roi_anchors(self):
#        return {name: roi.position for name, roi in self._rois.items()}

    def get_roi_position(self, name):
        if not isinstance(name, str):
            raise TypeError('ROI name must be of type str.')
        if name not in self._rois:
            raise KeyError('No ROI with name "{0}" found in ROI list.'.format(name))
        return self._rois[name].position + self.origin

#    def get_roi_anchor(self, name):
#        if not isinstance(name, str):
#            raise TypeError('ROI name must be of type str.')
#        if name not in self._rois:
#            raise KeyError('No ROI with name "{0}" found in ROI list.'.format(name))
#        return self._rois[name].position

    def set_roi_position(self, name, new_pos):
        if name not in self._rois:
            raise KeyError('ROI with name "{0}" not found in ROIlist "{1}".\n'
                           'Unable to change ROI position.'.format(name, self.name))
        self._rois[name].position = np.array(new_pos, dtype=float) - self.origin
        return None

#    def set_roi_anchor(self, name, new_pos):
#        if name not in self._rois:
#            raise KeyError('ROI with name "{0}" not found in ROIlist "{1}".\n'
#                           'Unable to change ROI position.'.format(name, self.name))
#        self._rois[name].position = new_pos
#        return None

    def rename_roi(self, name, new_name=None):
        if new_name is not None and not isinstance(new_name, str):
            raise TypeError('ROI name to set must be of type str or None.')
        if name not in self._rois:
            raise KeyError('Name "{0}" not found in ROI list.'.format(name))
        if new_name in self._rois:
            raise NameError('New ROI name "{0}" already present in current ROI list.')
        self._rois[name].name = new_name
        self._rois[new_name] = self._rois.pop(name)
        return None

    def add_roi(self, position, name=None): # change the default name setting
        if isinstance(position, RegionOfInterest):
            roi_inst = position
        else:
            position = position - self.origin
            # Create a generic name from the roi_nametag if it is set and no name is given.
            if name is None and self._roi_tag is not None:
                tag_index = len(self._rois)
                while True:
                    tag_index += 1
                    name = '{0}{1:d}'.format(self._roi_tag, tag_index)
                    if name not in self._rois:
                        break
            roi_inst = RegionOfInterest(position=position, name=name)
        if roi_inst.name in self._rois:
            raise ValueError('ROI with name "{0}" already present in ROIlist "{1}".\n'
                             'Could not add ROI to ROIlist'.format(roi_inst.name, self.name))
        self._rois[roi_inst.name] = roi_inst
        return None

    def delete_roi(self, name):
        if not isinstance(name, str):
            raise TypeError('ROI name to delete must be of type str.')
        if name not in self._rois:
            raise KeyError('Name "{0}" not found in ROI list.'.format(name))
        del self._rois[name]
        return None


# to modify : 
    def set_cam_image(self, image_arr, image_extent):
        """

        @param scalar[][] image_arr:
        @param float[2][2] image_extent:
        """
        if image_arr is None:
            self._cam_image = None
            self._cam_image_extent = None
        else:
            roi_x_pos, roi_y_pos, roi_z_pos = self.origin
            x_extent = (image_extent[0][0] - roi_x_pos, image_extent[0][1] - roi_x_pos)
            y_extent = (image_extent[1][0] - roi_y_pos, image_extent[1][1] - roi_y_pos)
            self._cam_image = np.array(image_arr)
            self._cam_image_extent = (x_extent, y_extent)
        return


    def to_dict(self):
        return {'name': self.name,
                'roi_nametag': self.roi_nametag,
                'creation_time': self.creation_time_as_str,
                'cam_image': self.cam_image,
                'cam_image_extent': self.cam_image_extent,
                'rois': [roi.to_dict() for roi in self._rois.values()]}

    @classmethod
    def from_dict(cls, dict_repr):
        if not isinstance(dict_repr, dict):
            raise TypeError('Parameter to generate RegionOfInterestList instance from must be of type '
                            'dict.')
        if 'rois' in dict_repr:
            roi_list = [RegionOfInterest.from_dict(roi) for roi in dict_repr.get('rois')]
        else:
            roi_list = None
            
        roilist = cls(name=dict_repr.get('name'),
                  creation_time=dict_repr.get('creation_time'),
                  cam_image=dict_repr.get('cam_image'),
                  cam_image_extent=dict_repr.get('cam_image_extent'),
                  roi_list=roi_list,
                  roi_nametag=dict_repr.get('roi_nametag'))
        return roilist # attention: do not mix roilist and roi_list .. think of renaming things to make it less confusing


class RegionOfInterest:
    """
    The actual individual roi is saved in this generic object.
    """

    def __init__(self, position, name=None):
        # Name of the ROI
        self._name = ''
        # Relative ROI position within the ROIlist (x,y,z) 
        self._position = np.zeros(3)
        # Initialize properties
        self.position = position
        self.name = name

    @property
    def name(self):
        return str(self._name)

    @name.setter
    def name(self, new_name):
        if new_name is not None and not isinstance(new_name, str):
            raise TypeError('Name to set must be either None or of type str.')

        if not new_name:
            new_name = datetime.now().strftime('roi_%Y%m%d%H%M%S%f') # change format
        self._name = str(new_name)
        return None

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, pos):
        if len(pos) != 3:
            raise ValueError('ROI position to set must be iterable of length 3 (X, Y).')
        self._position = np.array(pos, dtype=float)
        return None

    def to_dict(self):
        return {'name': self.name, 'position': tuple(self.position)}

    @classmethod
    def from_dict(cls, dict_repr):
        return cls(**dict_repr)


class RoiLogic(GenericLogic):
    """
    This is the Logic class for selecting regions of interest.
    """

    # declare connectors
    stage = Connector(interface='MotorInterface') 
    

    # status vars
    _roi_list = StatusVar(default=dict())  # Notice constructor and representer further below
    _active_roi = StatusVar(default=None)
    _roi_width = StatusVar(default=20) # check which units ?? to be corrected. Corresponds to FOV ??

    # Signals for connecting modules
    sigRoiUpdated = QtCore.Signal(str, str, np.ndarray)  # old_name, new_name, current_position
    sigActiveRoiUpdated = QtCore.Signal(str)
    sigRoiListUpdated = QtCore.Signal(dict)  # Dict containing ROI parameters to update
    sigWidthUpdated = QtCore.Signal(float)


    def __init__(self, config, **kwargs):
        super().__init__(config=config, **kwargs)

        # threading
        self._threadlock = Mutex()
        return None

    def on_activate(self):
        """ Initialisation performed during activation of the module.
        """

        # Initialise the ROI scan image (xy confocal image) if not present
#        if self._roi_list.cam_image is None:
#            self.set_cam_image(False)

        self.sigRoiListUpdated.emit({'name': self.roi_list_name,
                                 'roi_nametag': self.roi_nametag,
                                 'rois': self.roi_positions,
                                 'cam_image': self.roi_list_cam_image,
                                 'cam_image_extent': self.roi_list_cam_image_extent
                                 })
        self.sigActiveRoiUpdated.emit('' if self.active_roi is None else self.active_roi)
        return None

    def on_deactivate(self):
        pass

### this has to be set: the default directory for data saving
#    @property
#    def data_directory(self):
#        return self.savelogic().data_dir


    @property
    def active_roi(self):
        return self._active_roi

    @active_roi.setter
    def active_roi(self, name):
        self.set_active_roi(name)
        return None

    @property
    def roi_names(self):
        """ 
        """
        return self._roi_list.roi_names

    @property
    def roi_positions(self):
        return self._roi_list.roi_positions

#    @property
#    def roi_anchors(self):
#        return self._roi_list.roi_anchors

    @property
    def roi_list_name(self):
        return self._roi_list.name

    @roi_list_name.setter
    def roi_list_name(self, name):
        self.rename_roi_list(new_name=name)

    @property
    def roi_nametag(self):
        return self._roi_list.roi_nametag

    @roi_nametag.setter
    def roi_nametag(self, tag):
        self.set_roi_nametag(tag)
        return

    @property
    def roi_list_origin(self):
        return self._roi_list.origin

    @property
    def roi_list_creation_time(self):
        return self._roi_list.creation_time

    @property
    def roi_list_creation_time_as_str(self):
        return self._roi_list.creation_time_as_str

    @property
    def roi_list_cam_image(self):
        return self._roi_list.cam_image

    @property
    def roi_list_cam_image_extent(self):
        return self._roi_list.cam_image_extent

    @property
    def roi_width(self):
        return float(self._roi_width)

    @roi_width.setter
    def roi_width(self, new_width):
        self.set_roi_width(new_width)
        return None
  
    @property
    def stage_position(self):
        pos = self.stage().get_pos() # this returns a dictionary of the format {'x': pos_x, 'y': pos_y} 
        return list(pos.values())[:3] # get only the dictionary values as a list. [:3] as safety to get only the x y axis and empty z value

    @QtCore.Slot(str)
    def set_roi_nametag(self, tag):
        if tag is None or isinstance(tag, str):
            if tag == '':
                tag = None
            self._roi_list.roi_nametag = tag
            self.sigRoiListUpdated.emit({'roi_nametag': self.roi_nametag})
        else:
            self.log.error('ROI name tag must be str or None.')
        return None

    @QtCore.Slot()
    @QtCore.Slot(np.ndarray)
    def add_roi(self, position=None, name=None, emit_change=True):
        """
        Creates a new ROI and adds it to the current ROI list.
        ROI can be optionally initialized with position and name.

        @param str name: Name for the ROI (must be unique within ROI list).
                         None (default) will create generic name.
        @param scalar[3] position: Iterable of length 3 representing the (x, y, z) position with
                                   respect to the ROI list origin. None (default) causes the current
                                   crosshair position to be used.
        @param bool emit_change: Flag indicating if the changed ROI set should be signaled.
        """
        # Get current stage position from motor interface if no position is provided.
        if position is None:
            position = self.stage_position
#        else:  # for tests
#            print("I received a position from click")

        current_roi_set = set(self.roi_names)

        # Add ROI to current ROI list
        self._roi_list.add_roi(position=position, name=name)

        # Get newly added ROI name from comparing ROI names before and after addition of new ROI
        roi_name = set(self.roi_names).difference(current_roi_set).pop()

        # Notify about a changed set of ROIs if necessary
        if emit_change:
            self.sigRoiUpdated.emit('', roi_name, self.get_roi_position(roi_name))

        # Set newly created ROI as active roi
        self.set_active_roi(roi_name)
        return None

    @QtCore.Slot()
    def delete_roi(self, name=None):
        """
        Deletes the given roi from the roi list.

        @param str name: Name of the roi to delete. If None (default) delete active roi.
        @param bool emit_change: Flag indicating if the changed roi set should be signaled.
        """
        if len(self.roi_names) == 0:
            self.log.warning('Can not delete ROI. No ROI present in ROI list.')
            return None
        if name is None:
            if self.active_roi is None:
                self.log.error('No ROI name to delete and no active ROI set.')
                return None
            else:
                name = self.active_roi

        self._roi_list.delete_roi(name) # see method defined in RegionOfInterestList class

        if self.active_roi == name:
            if len(self.roi_names) > 0:
                self.set_active_roi(self.roi_names[0])
            else:
                self.set_active_roi(None)

        # Notify about a changed set of ROIs if necessary
        self.sigRoiUpdated.emit(name, '', np.zeros(3))
        return None

    @QtCore.Slot()
    def delete_all_roi(self):
        self.active_roi = None
        for name in self.roi_names:
            self._roi_list.delete_roi(name)
            self.sigRoiUpdated.emit(name, '', np.zeros(3))
        return None

    @QtCore.Slot(str)
    @QtCore.Slot(str, str)
    def rename_roi(self, new_name, name=None):
        """

        @param str name:
        @param str new_name:
        """
        if not isinstance(new_name, str) or not new_name:
            self.log.error('ROI name to set must be str of length > 0.')
            return None

        if name is None:
            if self.active_roi is None:
                self.log.error('Unable to rename ROI. No ROI name given and no active ROI set.')
                return None
            else:
                name = self.active_roi

        self._roi_list.rename_roi(name=name, new_name=new_name)

        self.sigRoiUpdated.emit(name, new_name, self.get_roi_position(new_name))

        if self.active_roi == name:
            self.set_active_roi(new_name)
        return None

    @QtCore.Slot(str)
    def set_active_roi(self, name=None):
        """
        Set the name of the currently active ROI
        @param name:
        """
        if not isinstance(name, str) and name is not None:
            self.log.error('ROI name must be of type str or None.')
        elif name is None or name == '':
            self._active_roi = None
        elif name in self.roi_names:
            self._active_roi = str(name)
        else:
            self.log.error('No ROI with name "{0}" found in ROI list.'.format(name))

        self.sigActiveRoiUpdated.emit('' if self.active_roi is None else self.active_roi)
        return None

    def get_roi_position(self, name=None):
        """
        Returns the ROI position of the specified ROI or the active ROI if none is given.

        @param str name: Name of the ROI to return the position for.
                             If None (default) the active ROI position is returned.
        @return float[3]: Coordinates of the desired ROI (x,y,z)
        """
        if name is None:
            name = self.active_roi
        return self._roi_list.get_roi_position(name)

#    def get_roi_anchor(self, name=None):
#        """
#        Returns the ROI anchor position (excluding sample movement) of the specified ROI or the
#        active ROI if none is given.
#
#        @param str name: Name of the ROI to return the position for.
#                         If None (default) the active ROI position is returned.
#        @return float[3]: Coordinates of the desired ROI anchor (x,y,z)
#        """
#        if name is None:
#            name = self.active_roi
#        return self._roi_list.get_roi_anchor(name)


##### we probably don't need those
#    @QtCore.Slot()
#    def move_roi_from_poi_position(self, name=None, position=None):
#        if position is None:
#            position = self.scanner_position
#
#        if name is None:
#            if self.active_poi is None:
#                self.log.error('Unable to set POI position. '
#                               'No POI name given and no active POI set.')
#                return
#            else:
#                name = self.active_poi
#
#        if len(position) != 3:
#            self.log.error('POI position must be iterable of length 3.')
#            return
#        if not isinstance(name, str):
#            self.log.error('POI name must be of type str.')
#
#        shift = position - self.get_poi_position(name)
#        self.add_roi_position(self.roi_origin + shift)
#        return

#    @QtCore.Slot()
#    def set_roi_anchor_from_position(self, name=None, position=None):
#        if position is None:
#            position = self.stage_position
#
#        if name is None:
#            if self.active_roi is None:
#                self.log.error('Unable to set ROI position. '
#                               'No ROI name given and no active ROI set.')
#                return None
#            else:
#                name = self.active_roi
#
#        if len(position) != 3:
#            self.log.error('ROI position must be iterable of length 3.')
#            return None
#        if not isinstance(name, str):
#            self.log.error('ROI name must be of type str.')
#
#        shift = position - self.get_roi_position(name)
#        self._roi_list.set_roi_anchor(name, self.get_roi_anchor(name) + shift)
#        self.sigRoiUpdated.emit(name, name, self.get_roi_position(name))
#        return None

    @QtCore.Slot(str)
    def rename_roi_list(self, new_name):
        if not isinstance(new_name, str) or new_name == '':
            self.log.error('ROI list name to set must be str of length > 0.')
            return None
        self._roi_list.name = new_name
        self.sigRoiListUpdated.emit({'name': self.roi_name})
        return None


    @QtCore.Slot()
    def go_to_roi(self, name=None):
        """
        Move translation stage to the given roi.

        @param str name: the name of the ROI
        """
        if name is None:
            name = self.active_roi
        if not isinstance(name, str):
            self.log.error('ROI name to move to must be of type str.')
            return None
        self.move_stage(self.get_roi_position(name))
        return None

    def move_stage(self, position):
        """ 
        Move the translation stage to position.
        
        @param float position: tuple (x, y, z)
        """
        # this functions accepts a tuple (x, y, z) as argument because it will be called with the roi position as argument. 
        # Hence, the input argument has to be converted into a dictionary of format {'x': x, 'y': y} to be passed to the translation stage function.
        if len(position) != 3: # modify later to use only 2 coordinates but ask before ..
            self.log.error('Stage position to set must be iterable of length 3.')
            return None
        axis_label = ('x', 'y', 'z')
        pos_dict = dict([*zip(axis_label, position)])
        self.stage().move_abs(pos_dict) 
        return None

#    @QtCore.Slot()
#    def set_cam_image(self, emit_change=True):
#        """ Get the current xy scan data and set as scan_image of ROI. """
#        self._roi_list.set_scan_image() # add the camera logic as connector to get the image ?? or do not show image on ROI map ?
#
#        if emit_change:
#            self.sigRoiListUpdated.emit({'scan_image': self.roi_list_scan_image,
#                                     'scan_image_extent': self.roi_scan_image_extent})
#        return None

    @QtCore.Slot()
    def reset_roi_list(self):
        self._roi_list = RegionOfInterestList() # create an instance of the RegionOfInterestList class
        #self.set_scan_image(False)
        self.sigRoiListUpdated.emit({'name': self.roi_list_name,
                                 'roi_nametag': self.roi_nametag,
                                 'rois': self.roi_positions,
                                 'cam_image': self.roi_list_cam_image,
                                 'cam_image_extent': self.roi_list_cam_image_extent
                                 })
        self.set_active_roi(None)
        return None


    @QtCore.Slot(float)
    def set_roi_width(self, width):
        self._roi_width = float(width)
        self.sigWidthUpdated.emit(width)
        return None





#### to do : 
#    def save_roi_list(self):
#        """
#        Save all current absolute POI coordinates to a file.
#        Save ROI history to a second file.
#        Save ROI scan image (if present) to a third file (binary numpy .npy-format).
#        """
#        # File path and names
#        filepath = self.savelogic().get_path_for_module(module_name='ROIs')
#        roi_name_no_blanks = self.roi_name.replace(' ', '_')
#        timestamp = datetime.now()
#        pois_filename = '{0}_poi_list'.format(roi_name_no_blanks)
#        roi_history_filename = '{0}_{1}_history.npy'.format(
#            timestamp.strftime('%Y%m%d-%H%M-%S'), roi_name_no_blanks)
#        roi_image_filename = '{0}_{1}_scan_image.npy'.format(
#            timestamp.strftime('%Y%m%d-%H%M-%S'), roi_name_no_blanks)
#
#        # Metadata to save in both file headers
#        x_extent, y_extent = self.roi_scan_image_extent
#        parameters = OrderedDict()
#        parameters['roi_name'] = self.roi_name
#        parameters['poi_nametag'] = '' if self.poi_nametag is None else self.poi_nametag
#        parameters['roi_creation_time'] = self.roi_creation_time_as_str
#        parameters['scan_image_x_extent'] = '{0:.9e},{1:.9e}'.format(*x_extent)
#        parameters['scan_image_y_extent'] = '{0:.9e},{1:.9e}'.format(*y_extent)
#
#        ##################################
#        # Save POI positions to first file
#        ##################################
#        poi_dict = self.poi_positions
#        poi_positions = np.array(tuple(poi_dict.values()), dtype=float)
#        data = OrderedDict()
#        # Save POI names in the first column
#        data['name'] = np.array(tuple(poi_dict), dtype=str)
#        # Save x,y,z coordinates in the following 3 columns
#        data['X (m)'] = poi_positions[:, 0]
#        data['Y (m)'] = poi_positions[:, 1]
#        data['Z (m)'] = poi_positions[:, 2]
#
#        self.savelogic().save_data(data,
#                                   timestamp=timestamp,
#                                   filepath=filepath,
#                                   parameters=parameters,
#                                   filelabel=pois_filename,
#                                   fmt=['%s', '%.6e', '%.6e', '%.6e'])
#
#        ############################################
#        # Save ROI history to second file (binary) if present
#        ############################################
#        if len(self.roi_pos_history) > 1:
#            np.save(os.path.join(filepath, roi_history_filename), self.roi_pos_history)
#
#        #######################################################
#        # Save ROI scan image to third file (binary) if present
#        #######################################################
#        if self.roi_scan_image is not None:
#            np.save(os.path.join(filepath, roi_image_filename), self.roi_scan_image)
#        return
#
#    def load_roi_list(self, complete_path=None):
#        if complete_path is None:
#            return
#        filepath, filename = os.path.split(complete_path)
#
#        # Try to detect legacy file format
#        is_legacy_format = False
#        if not complete_path.endswith('_poi_list.dat'):
#            self.log.info('Trying to read ROI from legacy file format...')
#            with open(complete_path, 'r') as file:
#                for line in file.readlines():
#                    if line.strip() == '#POI Name\tPOI Key\tX\tY\tZ':
#                        is_legacy_format = True
#                    elif not line.startswith('#'):
#                        break
#            if not is_legacy_format:
#                self.log.error('Unable to load ROI from file. File format not understood.')
#                return
#
#        if is_legacy_format:
#            filetag = filename.split('_', 1)[1].rsplit('.dat', 1)[0]
#        else:
#            filetag = filename.rsplit('_poi_list.dat', 1)[0]
#
#        # Read POI data as well as roi metadata from textfile
#        poi_names = np.loadtxt(complete_path, delimiter='\t', usecols=0, dtype=str)
#        if is_legacy_format:
#            poi_coords = np.loadtxt(complete_path, delimiter='\t', usecols=(2, 3, 4), dtype=float)
#        else:
#            poi_coords = np.loadtxt(complete_path, delimiter='\t', usecols=(1, 2, 3), dtype=float)
#
#        # Create list of POI instances
#        poi_list = [PointOfInterest(pos, poi_names[i]) for i, pos in enumerate(poi_coords)]
#
#        roi_name = None
#        poi_nametag = None
#        roi_creation_time = None
#        scan_extent = None
#        if is_legacy_format:
#            roi_name = filetag
#        else:
#            with open(complete_path, 'r') as file:
#                for line in file.readlines():
#                    if not line.startswith('#'):
#                        break
#                    if line.startswith('#roi_name:'):
#                        roi_name = line.split('#roi_name:', 1)[1].strip()
#                    elif line.startswith('#poi_nametag:'):
#                        poi_nametag = line.split('#poi_nametag:', 1)[1].strip()
#                    elif line.startswith('#roi_creation_time:'):
#                        roi_creation_time = line.split('#roi_creation_time:', 1)[1].strip()
#                    elif line.startswith('#scan_image_x_extent:'):
#                        scan_x_extent = line.split('#scan_image_x_extent:', 1)[1].strip().split(',')
#                    elif line.startswith('#scan_image_y_extent:'):
#                        scan_y_extent = line.split('#scan_image_y_extent:', 1)[1].strip().split(',')
#            scan_extent = ((float(scan_x_extent[0]), float(scan_x_extent[1])),
#                           (float(scan_y_extent[0]), float(scan_y_extent[1])))
#            poi_nametag = None if not poi_nametag else poi_nametag
#
#        # Read ROI position history from binary file
#        history_filename = os.path.join(filepath, '{0}_history.npy'.format(filetag))
#        try:
#            roi_history = np.load(history_filename)
#        except FileNotFoundError:
#            roi_history = None
#
#        # Read ROI scan image from binary file
#        image_filename = os.path.join(filepath, '{0}_scan_image.npy'.format(filetag))
#        try:
#            roi_scan_image = np.load(image_filename)
#        except FileNotFoundError:
#            roi_scan_image = None
#
#        # Reset current ROI and initialize new one from loaded data
#        self.reset_roi()
#        self._roi = RegionOfInterest(name=roi_name,
#                                     creation_time=roi_creation_time,
#                                     history=roi_history,
#                                     scan_image=roi_scan_image,
#                                     scan_image_extent=scan_extent,
#                                     poi_list=poi_list,
#                                     poi_nametag=poi_nametag)
#        print(poi_nametag, self.poi_nametag)
#        self.sigRoiUpdated.emit({'name': self.roi_name,
#                                 'poi_nametag': self.poi_nametag,
#                                 'pois': self.poi_positions,
#                                 'history': self.roi_pos_history,
#                                 'scan_image': self.roi_scan_image,
#                                 'scan_image_extent': self.roi_scan_image_extent})
#        self.set_active_poi(None if len(poi_names) == 0 else poi_names[0])
#        return

    @_roi_list.constructor
    def dict_to_roi(self, roi_dict):
        return RegionOfInterestList.from_dict(roi_dict)

    @_roi_list.representer
    def roi_list_to_dict(self, roi_list):
        return roi_list.to_dict()

